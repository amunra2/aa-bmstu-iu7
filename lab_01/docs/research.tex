\chapter{Исследовательская часть}

В данном разделе будут приведены примеры работы программа, а также проведен сравнительный анализ алгоритмов при различных ситуациях на основе полученных данных.

\section{Технические характеристики}

Технические характеристики устройства, на котором выполнялось тестирование представлены далее:

\begin{itemize}
    \item операционная система: Ubuntu 20.04.3 \cite{ubuntu} Linux \cite{linux} x86\_64;
    \item память: 8 GiB;
    \item процессор: Intel® Core™ i5-7300HQ CPU @ 2.50GHz \cite{intel}.
\end{itemize}

При тестировании ноутбук был включен в сеть электропитания. Во время тестирования ноутбук был нагружен только встроенными приложениями окружения, а также системой тестирования.

\section{Демонстрация работы программы}

На рисунке \ref{img:example} представлен результат работы программы.

\imgHeight{120mm}{example}{Пример работы программы}
\clearpage

\section{Время выполнения алгоритмов}

Как было сказано выше, используется функция замера процессорного времени process\_time(...) из библиотеки time на Python. Функция возвращает пользовательское процессорное время типа float.

Использовать функцию приходится дважды, затем из конечного времени нужно вычесть начальное, чтобы получить результат.

Замеры проводились для длины слова от 0 до 9 по 100 раз на различных входных данных.

Результаты замеров приведены в таблице \ref{tbl:time_mes} (время в мс).

\begin{table}[h]
    \begin{center}
        \begin{threeparttable}
        \captionsetup{justification=raggedleft,singlelinecheck=off}
        \caption{Результаты замеров времени}
        \label{tbl:time_mes}
        \begin{tabular}{|c|c|c|c|c|}
            \hline
            Длина & Л.(рек) & Л.(матр.)& Л.(рек с матр.) & Д.-Л.(рек.)  \\
            0 & 0.0033 & 0.0074 & 0.0089 & 0.0032 \\ 
            \hline
            1 & 0.0081 & 0.0111 & 0.0156 & 0.0092 \\ 
            \hline
            2 & 0.0261 & 0.0191 & 0.0273 & 0.0280 \\ 
            \hline
            3 & 0.0647 & 0.0115 & 0.0192 & 0.0570 \\ 
            \hline
            4 & 0.1654 & 0.0113 & 0.0226 & 0.2544 \\ 
            \hline
            5 & 0.8275 & 0.0141 & 0.0260 & 1.2789 \\ 
            \hline
            6 & 4.1587 & 0.0199 & 0.0365 & 7.1449 \\ 
            \hline
            7 & 24.6731 & 0.0309 & 0.0568 & 42.2119 \\ 
            \hline
            8 & 125.5106 & 0.0317 & 0.0613 & 227.0448 \\ 
            \hline
            9 & 651.1621 & 0.0393 & 0.0752 & 1278.5680 \\ 
            \hline
		\end{tabular}
    \end{threeparttable}
\end{center}
\end{table}

Также на рисунках \ref{img:graph_lev_rec_and_cache}, \ref{img:graph_lev_mat_and_cache}, \ref{img:graph_lev_and_dam_lev} приведены графические результаты замеров.

\imgHeight{100mm}{graph_lev_rec_and_cache}{Сравнение по времени алгоритмов Левенштейна с использованием рекурсии и с использованием кеша (матрица + рекурсия)}
\imgHeight{100mm}{graph_lev_mat_and_cache}{Сравнение алгоритмов нахождения расстояния Левенштейна матричного и с кешем в виде матрицы}
\imgHeight{100mm}{graph_lev_and_dam_lev}{Сравнение по времени рекурсивных алгоритмов Левенштейна и Дамерау-Левенштейна}
\clearpage


\section{Использование памяти}

С точки зрения замеров и сравнения используемой памяти, алгоритмы Левенштейна и Дамерау-Левенштейна не отличаются друг от друга.
Тогда рассмотрим только рекурсивную и матричную реализации данных алгоритмов.

Пусть:
\begin{itemize}
    \item n - длина строки S1
    \item m - длина строки S2
\end{itemize}

Тогда затраты по памяти будут такими:
\begin{itemize}
    \item алгоритм нахождения расстояния Левенштейна (рекурсивный), где для каждого вызова:

    \begin{itemize}
        \item для S1, S2 - (n + m) * sizeof(char)
        \item для n, m - 2 * sizeof(int)
        \item доп. переменные - 2 * sizeof(int)
        \item адрес возврата
    \end{itemize}

    \item алгоритм нахождения расстояния Левенштейна с использованием кеша в виде матрицы (память на саму матрицу: ((n + 1) * (m + 1)) * sizeof(int)) (рекурсивный), где для каждого вызова:

    \begin{itemize}
        \item для S1, S2 - (n + m) * sizeof(char)
        \item для n, m - 2 * sizeof(int)
        \item доп. переменные - 2 * sizeof(int)
        \item ссылка на матрицу - 8 байт
        \item адрес возврата
    \end{itemize}

    \item алгоритм нахождения расстояния Дамерау-Левенштейна (рекурсивный), где для каждого вызова:

    \begin{itemize}
        \item для S1, S2 - (n + m) * sizeof(char)
        \item для n, m - 2 * sizeof(int)
        \item доп. переменные - 2 * sizeof(int)
        \item адрес возврата
    \end{itemize}


    \item алгоритм нахождения расстояния Левенштейна (матричный):

    \begin{itemize}
        \item для матрицы - ((n + 1) * (m + 1)) * sizeof(int)) 
        \item текущая строка матрицы - (n + 1) * sizeof(int)
        \item для S1, S2 - (n + m) * sizeof(char)
        \item для n, m - 2 * sizeof(int)
        \item доп. переменные - 3 * sizeof(int)
        \item адрес возврата
    \end{itemize}
\end{itemize}

\section*{Вывод}

Исходя из замеров по памяти, итеративные алгоритмы проигрывают рекурсивным, потому что максимальный размер памяти в них растет, как произведение длин строк, а в рекурсивных - как сумма длин строк.

Исходя из полученных результатов замера времени, при увеличении длины слова рекурсивная реализация алгоритма Левенштейна начинает сильно проигрывать матричной реализации - при длине слова в 8 символов эта разница превышает несколько порядков.

Алгоритмы нахождения расстояния Левенштейна и Дамерау-Левенштейна примерно сопоставимы между собой, поскольку оба имеют рекурсивную реализацию, поэтому расхождение по времени у них не большое.
