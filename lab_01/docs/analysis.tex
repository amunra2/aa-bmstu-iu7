\chapter{Аналитическая часть}

В данном разделе будут разобраны алгоритмы нахождения расстояния - алгоритмы Левенштейна и Дамерау-Левенштейна.

\section{Расстояние Левенштейна}

\textbf{Расстояние Левенштейна} \cite{levenshtein} между двумя строками - метрика, позволяющая определить «схожесть» двух строк — минимальное количество операций вставки одного символа, удаления одного символа и замены одного символа на другой, необходимых для превращения одной строки в другую (каждая операция имеет свою цену - штраф). \newline


\textit{Редакционное предписание} - последовательность действий, необходимых для получения из первой строки вторую, и минимизирующую суммарную цену (и является расстоянием Левенштейна).\newline


Пусть $S_{1}$ и $S_{2}$ - две строки, длиной \textit{N} и \textit{M} соответственно. Введем следующие обозначения:
\begin{itemize}
        \item I (aнгл. Insert) - вставка символа в произвольной позиции ($w(\lambda,b)=1$);
        \item D (aнгл. Delete) - удаление символа в произвольной позиции ($w(\lambda,b)=1$);
        \item R (aнгл. Replace) - замена символа на другой ($w(a,b)=1, \medspace a \neq b$);
        \item M (aнгл. Match) - совпадение двух символов ($w(a,a)=0$). \newline
\end{itemize} 


С учетом введенных обозначений, расстояние Левенштейна может быть подсчитано по следующей рекуррентной формуле:


\begin{equation}
	\label{eq:D}
	D(i, j) = \begin{cases}
		
		0 &\text{i = 0, j = 0}\\
		i &\text{j = 0, i > 0}\\
		j &\text{i = 0, j > 0}\\
		\min \lbrace \\
		\qquad D(i, j-1) + 1\\
		\qquad D(i-1, j) + 1 &\text{i > 0, j > 0}\\
		\qquad D(i-1, j-1) + m(a[i], b[j]) &\text(\ref{eq:m})\\
		\rbrace
	\end{cases}
\end{equation}


Функция \ref{eq:m} определена как:
\begin{equation}
	\label{eq:m}
	m(a, b) = \begin{cases}
		0 &\text{если a = b,}\\
		1 &\text{иначе}
	\end{cases}.
\end{equation}


\section{Рекурсивный алгоритм нахождения расстояния Левенштейна}
Рекурсивный алгоритм вычисления расстояния Левенштейна реализует формулу \ref{eq:D}

Минимальная цена преобразования - минимальное значение приведенных вариантов.

Если полагать, что \textit{a', b'} - строки $a$ и $b$ без последнего символа соответственно, то цена преобразования из строки $a$ в $b$ может быть выражена так:

\begin{enumerate}
	\item сумма цены преобразования строки $a'$ в $b$ и цены проведения операции удаления, которая необходима для преобразования $a'$ в $a$;
	\item сумма цены преобразования строки $a$ в $b'$  и цены проведения операции вставки, которая необходима для преобразования $b'$ в $b$;
	\item сумма цены преобразования из $a'$ в $b'$ и операции замены, предполагая, что $a$ и $b$ оканчиваются на разные символы;
	\item цена преобразования из $a'$ в $b'$, предполагая, что $a$ и $b$ оканчиваются на один и тот же символ.
\end{enumerate}


\section{Матричный алгоритм нахождения расстояния Левенштейна}

Рекурсивный алгоритм вычисления расстояния Левенштейна может быть не эффективен при больших $i$ и $j$, так как множество промежуточных значений $D(i, j)$ вычисляются не один раз, что сильно замедляет время выполнения программы.

В качестве оптимизации можно использовать \textit{матрицу} для хранения промежуточных значений. Матрица имеет размеры:

\begin{equation}
	(length(S1)+ 1)*((length(S2) + 1),
\end{equation}
где $length(S)$ -- длина строки $S$

Значение в ячейке $[i, j]$ равно значению $D(S1[1...i], S2[1...j])$. Первая строка и первый столбец тривиальны. 

Всю таблицу (за исключением первого столбца и первой строки) заполняем в соответствии с формулой \ref{eq:mat}.
\begin{equation}
	\label{eq:mat}
	A[i][j] = min \begin{cases}
		A[i-1][j] + 1\\
		 A[i][j-1] + 1\\
		 A[i-1][j-1] + m(S1[i], S2[j])&\text(\ref{eq:m2})\\
	 \end{cases}.
 \end{equation}

Функция \ref{eq:m2} определена как:
\begin{equation}
\label{eq:m2}
m(S1[i], S2[j]) = \begin{cases}
0, &\text{если $S1[i - 1] = S2[j - 1]$,}\\
1, &\text{иначе}
\end{cases}.
\end{equation}

Результат вычисления расстояния Левенштейна будет ячейка матрицы с индексами $i = length(S1$) и $j = length(S2)$.

\section{Рекурсивный алгоритм нахождения расстояния Левенштейна с использованием кеша}

В качестве оптимизации рекурсивного алгоритма заполнения можно использовать \textit{кеш}, который будет представлять собой матрицу.

Суть оптимизации - при выполнении рекурсии происходит параллельное заполнение матрицы.

Если рекурсивный алгоритм выполняет прогон для данных, которые еще не были обработаны, то результат нахождения заносится в матрицу. Иначе, если обработанные данные встречаются снова, то для них расстояние не находится и алгоритм переходит к следующему шагу.


\section{Расстояние Дамерау — Левенштейна}

\textbf{Расстояние Дамерау-Левенштейна} \cite{damerau-levenshtein} между двумя строками, состоящими из конечного числа символов — это минимальное число операций вставки, удаления, замены одного символа и транспозиции двух соседних символов, необходимых для перевода одной строки в другую. 

Является модификацией расстояния Левенштейна - добавлена операции \textit{транспозиции}, то есть перестановки, двух символов.

Расстояние Дамерау — Левенштейна может быть найдено по формуле \ref{eq:d}, которая задана как


\begin{equation}
	\label{eq:d}
	d_{a,b}(i, j) = \begin{cases}
		\max(i, j), &\text{если }\min(i, j) = 0,\\
		\min \lbrace \\
			\qquad d_{a,b}(i, j-1) + 1,\\
			\qquad d_{a,b}(i-1, j) + 1,\\
			\qquad d_{a,b}(i-1, j-1) + m(a[i], b[j]), &\text{иначе}\\
			\qquad \left[ \begin{array}{cc}d_{a,b}(i-2, j-2) + 1, &\text{если }i,j > 1;\\
			\qquad &\text{}a[i] = b[j-1]; \\
			\qquad &\text{}b[j] = a[i-1]\\
			\qquad \infty, & \text{иначе}\end{array}\right.\\
		\rbrace
		\end{cases},
\end{equation}

Формула выводится по тем же соображениям, что и формула (\ref{eq:D}).


\section{Вывод}
В данном разделе были теоретически разобраны формулы Левенштейна и Дамерау-Левенштейна, которые являются рекуррентными, что позволяет реализовать их как рекурсивно, так и итерационно.

В качестве входных данных в программу будет подаваться две строки, также реализовано меню для вызова алгоритмов и замеров времени. Ограничением для работы программного продукта является то, что программе на вход может подаваться строка на английском или русском языке, а также программа должна корректно обрабатывать случай ввода пустых строк. 

Реализуемое ПО будет работать в двух режимах - пользовательский, в котором можно выбрать алгоритм и вывести для него посчитанное значение, а также экспериментальный режим, в котором можно произвести сравнение алгоритмов по времени работы на различных входных данных. 
