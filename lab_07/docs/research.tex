\chapter{Исследовательская часть}

В данном разделе будут приведены примеры работы программа, а также проведен сравнительный анализ алгоритмов при различных ситуациях на основе полученных данных.

\section{Технические характеристики}

Технические характеристики устройства, на котором выполнялось тестирование представлены далее:

\begin{itemize}
    \item операционная система: Ubuntu 20.04.3 \cite{ubuntu} Linux \cite{linux} x86\_64;
    \item память: 8 GiB;
    \item процессор: Intel® Core™ i5-7300HQ CPU @ 2.50GHz \cite{intel}.
\end{itemize}

При тестировании ноутбук был включен в сеть электропитания. Во время тестирования ноутбук был нагружен только встроенными приложениями окружения, а также системой тестирования.

\section{Демонстрация работы программы}

На рисунке \ref{img:example} представлен результат работы программы для всех алгоритмов -- поиск полным перебором, бинарного поиска и поиска сегментами.

\imgHeight{200mm}{example}{Пример работы программы}
\clearpage

\section{Время выполнения алгоритмов}

Как было сказано выше, используется функция замера процессорного времени  \textit{process\_time(...)} из библиотеки \textit{time} на \textit{Python}. Функция возвращает процессорное время типа float в секундах.

Использовать функцию приходится дважды, затем из конечного времени нужно вычесть начальное, чтобы получить результат.

Замеры проводились для всех ключей из словаря по 30 раз, чтобы добиться более точного значения времени работы каждого из алгоритмов.

Результаты замеров приведены на рисунке \ref{img:graph_time} в графическом виде.

\imgHeight{100mm}{graph_time}{Сравнение по времени алгоритмов поиска полным перебором, бинарного поиска и поиска сегментами}

\clearpage

\section{Количество сравнений при работе алгоритмов}

Для каждого алгоритма был проведен анализ по количеству сравнений для нахождения каждого ключа в словаре. При этом были составлены по две гистограммы для всех алгоритмов: 
\begin{itemize}
    \item ключи расположены в том же порядке, как и в словаре;
    \item ключи отсортированы в порядке убывания кол-ва сравнений. 
\end{itemize}

На рисунке \ref{img:graph_compfull} представлены гистограммы для поиска полным перебором, на рисунке \ref{img:graph_compbin} -- бинарного поиска, а на рисунке \ref{img:graph_compsegm} -- поиск сегментами.

\imgHeight{90mm}{graph_compfull}{Сравнение по количеству сравнений при поиске ключа в словаре алгоритмом полного перебора}
\imgHeight{90mm}{graph_compbin}{Сравнение по количеству сравнений при поиске ключа в словаре бинарным алгоритмом}
\imgHeight{90mm}{graph_compsegm}{Сравнение по количеству сравнений при поиске ключа в словаре алгоритмом разбиения на сегменты по общему признаку ключей}

\clearpage


\section{Вывод}

В результате эксперимента было получено, что алгоритм поиска в словаре разбиением на сегменты является самым быстрым алгоритмом (при далеких от начала словаря ключах быстрее алгоритма полного перебора в сотни раз, а также примерно в 10 раз быстрее алгоритма бинарного поиска) и имеет примерно одинаковое время поиска каждого ключа, как и алгоритм бинарного поиска. При этом скорость алгоритма полного перебора зависит от положения ключа в словаре и увеличивается пропорционально дальности нахождения ключа от начала словаря. Следовательно, для быстрого поиска стоит выбирать алгоритм поиска с разбиением на сегменты, но стоит максимально аккуратно разбивать на сегменты, чтобы добиться максимальной производительности.

Также при проведении эксперимента было определено, что алгоритм бинарного поиска в среднем требует минимального количества сравнений, по сравнению с остальными алгоритмами. Для словаря, который использовался при выполнении данной текущей работы алгоритму бинарного поиска нужно максимум 12 сравнений, для алгоритма с разбиением на сегменты -- 274 сравнения, а для алгоритма полного перебора -- 2695 сравнений. То есть, при необходимости, когда нужно сократить количество сравнений, стоит использовать алгоритм бинарного поиска в словаре.
