\chapter{Аналитическая часть}
В этом разделе будет представлена информация о словаре, а также об алгоритмах поиска в нем -- полным перебором, бинарном и сегментами.


\section{Словарь}

\textbf{Словарь} \cite{dictionary} -- тип данных, который позволяет хранить пары вида “ключ-значение” -- \textit{(k, v)}. Он поддерживает три операции -- добавление пары, поиск по ключу, удаление по ключу. В паре \textit{(k, v)} -- \textit{v} это значение, которое ассоциируется с ключом \textit{v}.

При поиске возвращается значение, которое ассоциируется с данным ключом, или “не найдено”, если по данному ключу нет значений.

В данной лабораторной работе:
\begin{itemize}
	\item ключ -- фамилия футболиста;
	\item значение -- информация о нем.
\end{itemize}


\section{Алгоритм полного перебора}

\textbf{Полный перебор} \cite{search-full} -- метод решения, при котором поочередно перебираются все ключи словаря, пока не будет найден нужный.

Чем дальше искомый ключ от начала словаря, тем выше трудоемкость алгоритм. Так, если на старте алгоритм затрагивает $b$ операций, а при сравнении $k$ операций, то:
\begin{itemize}
	\item элемент найден на первом сравнении за $b + k$ операций (лучший случай);
	\item элемент найден на \textit{i-ом} сравнении за $b + i \cdot k$ операций;
	\item элемент найден на последнем сравнении за $b +  N \cdot k$ операций, где $N$ -- размер словаря (худший случай);
\end{itemize}

При этом средняя трудоемкость равна:

\begin{equation}
	f = b + k \cdot \left(1 + \frac{N}{2} - \frac{1}{N + 1}\right)
\end{equation}


\section{Бинарный поиск}

\textbf{Бинарный поиск} \cite{search-bin} -- поиск в заранее отсортированном словаре, который заключается в сравнении со средним элементов, и, если ключ меньше, то продолжать поиск в левой части тем же методом, иначе -- в правой части.

Тогда случаи расположены следующим образом ($b$ -- кол-во операций алгоритма на старте):
\begin{itemize}
	\item элемент найден на первом сравнении с средним элементом -- трудоемкость $b + \log_2 1$ (лучший случай);
	\item элемент найден на \textit{i-ом} сравнении -- трудоемкость $b + \log_2 i$;
	\item элемент найден на последнем сравнении -- трудоёмкость $b +  \log_2 N$, где $N$ -- размер словаря (худший случай);
\end{itemize}



\section{Поиск с помощью сегментов}

\textbf{Поиск с помощью сегментов} \cite{search-segments} -- словарь разбивается на части, в каждую из которых попадают все элементы с некоторым общим признаком -- одинаковая первая буква, цифра, слово.

Обращение к сегменту равно сумме вероятностей обращения к его ключам. Пусть $P_i$ -- вероятность обращения к $i$-ому сегменту, а $p_j$ -- вероятность обращения к $j$-ому элементу $i$-ого сегмента. Тогда вероятность выбрать нужный сегмент высчитывается так 

\begin{equation}
	P_i = \sum_j p_j
\end{equation}

Затем ключи в каждом сегменте сортируются, чтобы внутри каждого сегмента можно было произвести бинарный поиск с сложностью $O(\log_2 k)$, где $k$ -- количество ключей в сегменте.

То есть, сначала выбирается нужный сегмент, а затем в нем с помощью бинарного поиска ищется нужный ключ.


При этом случаи располагаются так:
\begin{itemize}
	\item первым выбран верный сегмент, а нужный элемент -- серединный (лучший случай);
	\item нужный сегмент выбран последним, а поиск ключа в данном сегменте -- $\log_2 N$, где $N$ - число элементов в сегменте (худший случай);
\end{itemize}


При этом средняя трудоемкость поиска $i$-го элемента:

\begin{equation}
	\sum_{i \in \Omega}{\left(f_{\text{выбор сегмента i-ого элемента}} + f_{\text{бинарный поиск i-ого элемента}}\right)} \cdot p_i
\end{equation}



\section{Вывод}

В данном разделе было рассмотрено понятие словаря, а также алгоритма поиска в словаре -- полным перебором, бинарный и сегментами.

Программа будет получать на вход словарь, а также ключ, по которому нужно будет найти значение в данном словаре одним из трех алгоритмов, который также будет вводиться. Если словарь пуст или какое-то из значений введено неверно, то будет выдано сообщение об ошибке.

Реализуемое ПО дает возможность получить значение по ключу одним из трех алгоритмов поиска в словаре. Также имеется возможность провести тестирование по времени для рассматриваемых алгоритмов.
