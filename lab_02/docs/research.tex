\chapter{Исследовательская часть}

В данном разделе будут приведены примеры работы программа, а также проведен сравнительный анализ алгоритмов при различных ситуациях на основе полученных данных.

\section{Технические характеристики}

Технические характеристики устройства, на котором выполнялось тестирование представлены далее:

\begin{itemize}
    \item операционная система: Ubuntu 20.04.3 \cite{ubuntu} Linux \cite{linux} x86\_64;
    \item память: 8 GiB;
    \item процессор: Intel® Core™ i5-7300HQ CPU @ 2.50GHz \cite{intel}.
\end{itemize}

При тестировании ноутбук был включен в сеть электропитания. Во время тестирования ноутбук был нагружен только встроенными приложениями окружения, а также системой тестирования.

\section{Демонстрация работы программы}

На рисунке \ref{img:example} представлен результат работы программы.

\imgHeight{120mm}{example}{Пример работы программы}
\clearpage

\section{Время выполнения алгоритмов}

Как было сказано выше, используется функция замера процессорного времени process\_time(...) из библиотеки time на Python. Функция возвращает пользовательское процессорное время типа float.

Использовать функцию приходится дважды, затем из конечного времени нужно вычесть начальное, чтобы получить результат.

Замеры проводились для длины слова от 0 до 9 по 100 раз на различных входных данных.

Результаты замеров приведены в таблице \ref{tbl:time_mes} (время в мс).

\begin{table}[h]
    \begin{center}
        \begin{threeparttable}
        \captionsetup{justification=raggedright,singlelinecheck=off}
        \caption{Результаты замеров времени}
        \label{tbl:time_mes}
        \begin{tabular}{|c|c|c|c|c|}
            \hline
            Длина & Л.(рек) & Л.(матр.)& Л.(рек с матр.) & Д.-Л.(рек.)  \\
            \hline
            0 & 0.0033 & 0.0074 & 0.0089 & 0.0032 \\ 
            \hline
            1 & 0.0081 & 0.0111 & 0.0156 & 0.0092 \\ 
            \hline
            2 & 0.0261 & 0.0191 & 0.0273 & 0.0280 \\ 
            \hline
            3 & 0.0647 & 0.0115 & 0.0192 & 0.0570 \\ 
            \hline
            4 & 0.1654 & 0.0113 & 0.0226 & 0.2544 \\ 
            \hline
            5 & 0.8275 & 0.0141 & 0.0260 & 1.2789 \\ 
            \hline
            6 & 4.1587 & 0.0199 & 0.0365 & 7.1449 \\ 
            \hline
            7 & 24.6731 & 0.0309 & 0.0568 & 42.2119 \\ 
            \hline
            8 & 125.5106 & 0.0317 & 0.0613 & 227.0448 \\ 
            \hline
            9 & 651.1621 & 0.0393 & 0.0752 & 1278.5680 \\ 
            \hline
		\end{tabular}
    \end{threeparttable}
\end{center}
\end{table}

Также на рисунках \ref{img:graph_lev_rec_and_cache}, \ref{img:graph_lev_mat_and_cache}, \ref{img:graph_lev_and_dam_lev} приведены графические результаты замеров.

\imgHeight{100mm}{graph_lev_rec_and_cache}{Сравнение по времени алгоритмов Левенштейна с использованием рекурсии и с использованием кеша (матрица + рекурсия)}
\imgHeight{100mm}{graph_lev_mat_and_cache}{Сравнение алгоритмов нахождения расстояния Левенштейна матричного и с кешем в виде матрицы}
\imgHeight{100mm}{graph_lev_and_dam_lev}{Сравнение по времени рекурсивных алгоритмов Левенштейна и Дамерау-Левенштейна}
\clearpage


\section{Вывод}

Исходя из замеров по памяти, итеративные алгоритмы проигрывают рекурсивным, потому что максимальный размер памяти в них растет, как произведение длин строк, а в рекурсивных - как сумма длин строк.

В результате эксперимента было получено, что при длине строк в более 5 символов, алгоритм Левенштейна быстрее Дамерау-Левенштейна в 2 раза. В итоге, можно сказать, что при таких данных следует использовать алгоритм Левенштейна.

Также при проведении эксперимента было выявлено, что на длине строк в 4 символа рекурсивная реализация алгоритма Левенштейна в уже в 14 раз медленнее матричной реализации алгоритма. При увеличении длины строк в геометрической прогрессии растет и время работы рекурсивной реализации. Следовательно, стоит использовать матричную реализацию для строк длиной более 4 символов.
