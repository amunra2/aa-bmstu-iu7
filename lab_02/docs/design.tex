\chapter{Конструкторская часть}
В этом разделе будут представлено описание используемых типов данных, а также схемы алгоритмов перемножения матриц - стандартного, Винограда и оптимизации алгоритма Винограда.

\section{Описание используемых типов данных}

При реализации алгоритмов будут использованы следующие типы данных:

\begin{itemize}
	\item количество строк - целое число типа \textit{int}
	\item количество столбцов - целое число типа \textit{int}
	\item матрица - двумерный список типа \textit{int}
\end{itemize}


\section{Сведения о модулях программы}
Программа состоит из двух модулей:
\begin{itemize}
	\item $main.py$ - файл, содержащий весь служебный код;
    \item $algorythms.py$ - файл, содержащий код всех алгоритмов перемножения матриц. \newline
\end{itemize}


\section{Схемы алгоритмов}
На рисунке \ref{img:stand_alg} представлена схема алгоритма для стандартного умножения матриц. На рисунках \ref{img:vin_alg1}-\ref{img:vin_alg2} схема алгоритма Винограда умножения матриц, а на \ref{img:opt_vin_alg1}-\ref{img:opt_vin_alg2} - схема оптимизированного алгоритма Винограда. 

\imgScale{0.8}{stand_alg}{Схема стандартного алгоритма умножения матриц}
\imgScale{0.6}{vin_alg1}{Схема умножения матриц по алгоритму Винограда (часть 1)}
\imgScale{0.6}{vin_alg2}{Схема умножения матриц по алгоритму Винограда (часть 2)}
\imgScale{0.6}{opt_vin_alg1}{Схема умножения матриц по оптимизированному алгоритму Винограда (часть 1)}
\imgScale{0.6}{opt_vin_alg2}{Схема умножения матриц по оптимизированному алгоритму Винограда (часть 2)}

\clearpage


\section{Модель вычислений}

Чтобы провести вычисление трудоемкости алгоритмов умножения матриц, введем модель вычислений \cite{model}:

\begin{enumerate}
	\item операции из списка (\ref{for:opers}) имеют трудоемкость 1;
	\begin{equation}
		\label{for:opers}
		+, -, *, /, \%, ==, !=, <, >, <=, >=, [], ++, {-}-
	\end{equation}
	\item трудоемкость оператора выбора \code{if условие then A else B} рассчитывается, как (\ref{for:if});
	\begin{equation}
		\label{for:if}
		f_{if} = f_{\text{условия}} +
		\begin{cases}
			f_A, & \text{если условие выполняется,}\\
			f_B, & \text{иначе.}
		\end{cases}
	\end{equation}
	\item трудоемкость цикла рассчитывается, как (\ref{for:for});
	\begin{equation}
		\label{for:for}
		f_{for} = f_{\text{инициализации}} + f_{\text{сравнения}} + N(f_{\text{тела}} + f_{\text{инкремента}} + f_{\text{сравнения}})
	\end{equation}
	\item трудоемкость вызова функции равна 0.
\end{enumerate}


\section{Трудоемкость алгоритмов}

Рассчитаем трудоемкость алгоритмов умножения матриц.

\subsection{Стандартный алгоритм умножения матриц}

Для стандартного алгоритма умножения матриц трудоемкость будет слагаться из:

\begin{itemize}
	\item внешнего цикла по $i \in [1..M]$, трудоёмкость которого: $f = 2 + M \cdot (2 + f_{body})$;
	\item цикла по $j \in [1..N]$, трудоёмкость которого: $f = 2 + N \cdot (2 + f_{body})$;
	\item цикла по $k \in [1..K]$, трудоёмкость которого: $f = 2 + 10K$. \newline
\end{itemize}

Поскольку трудоемкость стандартного алгоритма равна трудоемкости внешнего цикла, то:

\begin{equation}
	\label{for:standard}
	f_{standard} = 2 + M \cdot (4 + N \cdot (4 + 10K)) = 2 + 4M + 4MN + 10MNK \approx 10MNK
\end{equation}


\subsection{Алгоритм Винограда}

Чтобы вычислить трудоемкость алгоритма Винограда, нужно учесть следующее: 

\begin{itemize}
	\item создания и инициализации массивов a\_tmp и b\_tmp, трудоёмкость которых (\ref{for:init}):
	\begin{equation}
		\label{for:init}
		f_{init} = M + N;
	\end{equation}
	
	\item заполнения массива a\_tmp, трудоёмкость которого (\ref{for:ATMP}):
	\begin{equation}
		\label{for:ATMP}
		f_{a\_tmp} = 2 + K (2 + \frac{M}{2} \cdot 11);
	\end{equation}
	
	\item заполнения массива b\_tmp, трудоёмкость которого (\ref{for:BTMP}):
	\begin{equation}
		\label{for:BTMP}
		f_{b\_tmp} = 2 + K (2 + \frac{N}{2} \cdot 11);
	\end{equation}
	
	\item цикла заполнения для чётных размеров, трудоёмкость которого (\ref{for:cycle}):
	\begin{equation}
		\label{for:cycle}
		f_{cycle} = 2 + M \cdot (4 + N \cdot (11 + \frac{K}{2} \cdot 23));
	\end{equation}
	
	\item цикла, который дополнительно нужен для подсчета значений при нечетном размере матрицы, трудоемкость которого (\ref{for:last}):
	\begin{equation}
		\label{for:last}
		f_{last} = \begin{cases}
			2, & \text{чётная,}\\
			4 + M \cdot (4 + 14N), & \text{иначе.}
		\end{cases}
	\end{equation}
\end{itemize}

Тогда для худшего случая (нечётный общий размер матриц) имеем (\ref{for:bad}):
\begin{equation}
	\label{for:bad}
	f_{worst} =  f_{a\_tmp} + f_{b\_tmp} + f_{cycle} + f_{last}\approx 11.5 \cdot MNK
\end{equation}

Для лучшего случая (чётный общий размер матриц) имеем (\ref{for:good}):
\begin{equation}
	\label{for:good}
f_{best} =  f_{a\_tmp} + f_{a\_tmp} + f_{cycle} + f_{last} \approx 11.5 \cdot MNK
\end{equation}


\subsection{Оптимизированный алгоритм Винограда}

Оптимизация заключается в:
\begin{itemize}
    \item использовании побитового сдвига вместо деления на 2;
    \item цикл, который был вынесен при нечетном размере матрицы, был занесен в общий цикл, тем самым в общем цикле происходят дополнительные вычисления при нечетном размере матрицы;
    \item операции сложения и вычитания заменены на операции $+=$ и $-=$ соответственно. \newline
\end{itemize}

Тогда трудоемкость оптимизированного алгоритма Винограда состоит из:

\begin{itemize}
	\item создания и инициализации массивов a\_tmp и b\_tmp (\ref{for:init});
	
	\item заполнения массива a\_tmp, трудоёмкость которого (\ref{for:ATMP});
	
	\item заполнения массива MV, трудоёмкость которого (\ref{for:BTMP});
	
	\item цикла заполнения для чётных размеров, трудоёмкость которого (\ref{for:impr_cycle}):
	\begin{equation}
		\label{for:impr_cycle}
		f_{cycle} =2 + M \cdot (4 + N \cdot (11 + \frac{K}{2} \cdot 18));
	\end{equation}
	
	\item условие, которое нужно для дополнительных вычислений при нечетном размере матрицы, трудоемкость которого (\ref{for:impr_last}):
	\begin{equation}
		\label{for:impr_last}
		f_{last} = 
		\begin{cases}
			1, & \text{чётная,}\\
			4 + M \cdot (4 + 10N), & \text{иначе.}
		\end{cases}
	\end{equation}
\end{itemize}

Тогда для худшего случая (нечётный общий размер матриц) имеем (\ref{for:bad_impr}):
\begin{equation}
	\label{for:bad_impr}
	f_{worst} = f_{MH} + f_{MV} + f_{cycle} + f_{last} \approx 9MNK
\end{equation}

Для лучшего случая (чётный общий размер матриц) имеем (\ref{for:good_impr}):
\begin{equation}
	\label{for:good_impr}
	f_{best} = f_{MH} + f_{MV} + f_{cycle} + f_{last} \approx 9MNK
\end{equation}


\section{Классы эквивалентности при тестировании}

Для тестирования выделены классы эквивалентности, представленные ниже.

\begin{enumerate}
	\item Одна из матриц - пустая.
	\item Количество столбцов одной матрицы не равно количеству строк второй матрицы.
	\item Перемножение квадратных матриц.
	\item Перемножение матриц разных размеров (при этом количество столбцов одной матрицы не равно количеству строк второй матрицы).
\end{enumerate}


\section{Вывод}

В данном разделе были построены схемы алгоритмов умножения матриц рассматриваемых в лабораторной работе, были описаны классы эквивалентности для тестирования, модули программы, а также проведена теоретическая оценка трудоемкости алгоритмов.
