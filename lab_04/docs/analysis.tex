\chapter{Аналитическая часть}
В этом разделе будет представлена информация по поводу многопоточности, а также теоретически описан алгоритм Брезенхема для построения отрезка, построение пучка которых будет распараллелена в данной лабораторной работе.


\section{Многопоточность}

\textbf{Многопоточность} \cite{threads} -- способность центрального процессора или одного ядра в многоядерном процессоре одновременно выполнять несколько процессов или потоков, соответствующим образом поддерживаемых операционной системой.

Упомянем важные определения:
\begin{itemize}
	\item \textbf{процесс} -- это программа в ходе своего выполнения. Когда мы выполняем программу или приложение, запускается процесс. Каждый процесс состоит из одного или нескольких потоков;

	\item \textbf{поток} -- это не что иное, как сегмент процесса. Потоки -- исполняемые сущности, которые выполняют задачи, стоящие перед исполняемым приложением. Процесс завершается, когда все потоки заканчивают выполнение.
\end{itemize}

Каждый поток в процессе -- это задача, которую должен выполнить процессор. Большинство процессоров сегодня умеют выполнять одновременно две задачи на одном ядре, создавая дополнительное виртуальное ядро. Это называется одновременная многопоточность или многопоточность $Hyper-Threading$, если речь о процессоре от Intel. 

Эти процессоры называются многоядерными процессорами. Таким образом, двухъядерный процессор имеет 4 ядра: два физических и два виртуальных. Каждое ядро может одновременно выполнять только один поток.

Как упоминалось выше, один процесс содержит несколько потоков, и одно ядро процессора может выполнять только один поток за единицу времени. Если мы пишем программу, которая запускает потоки последовательно, то есть передает выполнение в очередь одного конкретного ядра процессора, мы не раскрываем весь потенциал многоядерности. Остальные ядра просто стоят без дела, в то время как существуют задачи, которые необходимо выполнить. Если мы напишем программу таким образом, что она создаст несколько потоков для отнимающих много времени независимых функций, то мы сможем использовать другие ядра процессора, которые в противном случае пылились бы без дела. Можно выполнять эти потоки параллельно, тем самым сократив общее время выполнения процесса.


\section{Алгоритм Брезенхема пострения отрезка}

Алгоритм Брезенхема \cite{bres-alg}  был предложен Джеком Е. Брезенхэмом в 1962 году и предназначен для рисования фигур точками на плоскости. Этот алгоритм находит широкое распространение в машинной графике для рисования линий на экране. Алгоритм определяет, какие точки двумерного растра необходимо закрасить.

Графическая интерпретация алгоритма Брезенхема представлена на рисунке \ref{img:bres_example}.

\imgScale{0.6}{bres_example}{Алгоритм Брезенхема}

Для рисования прямых отрезков на плоскости с использованием алгоритма Брезенхема запишем уравнение прямой в общем виде

\begin{equation}
	y=kx+b
\end{equation}

или

\begin{equation}
	f(x,y)=Ax+By+C=0
\end{equation}

где коэффициенты A и B выражаются через коэффициенты $k$ и $b$ уравнения прямой. Если прямая проходит через две точки с координатами $(x_{1};y_{1})$ и $(x_{2};y_{2})$, то коэффициенты уравнения прямой определяются по формулам

\begin{equation}
	A=y_{2}-y_{1}
\end{equation}

\begin{equation}
	B=x_{1}-x_{2}
\end{equation}

\begin{equation}
	C=y_{1} \cdot x_{2}-y_{2} \cdot x_{1}
\end{equation}

Для любой растровой точки с координатами $(x_{i};y_{i})$ значение функция

\begin{equation}
	f(x_{i},y_{i}) = 0, \text{если точка лежит на прямой;}
\end{equation}

\begin{equation}
	f(x_{i},y_{i}) > 0, \text{если точка лежит ниже прямой;}
\end{equation}
	
\begin{equation}
	f(x_{i},y_{i}), \text{где i – номер отображаемой точки.}
\end{equation}

Таким образом, одним из методов решения того, какая из точек $P$ или $Q$ будет отображена на следующем шаге, является сравнение середины отрезка $|P-Q|$ со значением функции $f(x,y)$. Если значение $f(x,y)$ лежит ниже средней точки отрезка $|P-Q|$, то следующей отображаемой точкой будет точка $P$, иначе — точка $Q$.
Запишем приращение функции

\begin{equation}
	df=A \cdot dx+B \cdot dy
\end{equation}

После отображения точки с координатами $(x_{i},y_{i})$ принимается решение о следующей отображаемой точке. Для этого сравниваются приращения $dx$ и $dy$, характеризующие наличие или отсутствие перемещения по соответствующей координате. Эти приращения могут принимать значения 0 или 1. Следовательно, когда мы перемещаемся от точки вправо,

\begin{equation}
	df=A,
\end{equation}

когда мы перемещаемся от точки вправо и вниз, то

\begin{equation}
	df=A + B,
\end{equation}

когда мы перемещаемся от точки вниз, то

\begin{equation}
	df=B
\end{equation}

Нам известны координаты начала отрезка, то есть точки, заведомо лежащей на искомой прямой. Ставим туда первую точку и принимаем $f = 0$. От текущей точки можно сделать два шага — либо по вертикали (по горизонтали), либо по диагонали на один пиксель.
Направление движения по вертикали или горизонтали определяется коэффициентом угла наклона. В случае если угол наклона меньше 45º, и

\begin{equation}
|A|<|B|
\end{equation}

с каждым шагом осуществляется движение по горизонтали или диагонали.
Если угол наклона больше 45º, с каждым шагом движение осуществляется по вертикали или диагонали.


\section{Вывод}

В данном разделе было рассмотрено понятие многопоточности, а также алгоритм Брезенхема для построения отрезка, распараллеливание пучка которого и будет рассматриваться в данной лабораторной работе.

Программа имеет графический интерфейс. На вход через поля ввода будет подаваться длина отрезка в пучке, а также -- количество потоков, если выбран алгоритм с распараллеливанием.
При неверном вводе -- пустое поле ввода или значения меньше нуля -- будет выведено сообщение об ошибке. 

Реализуемое ПО дает возможность выбрать построение алгоритма с распараллеливанием или без него, а также выбрать количество потоков, по которым будет идти распараллеливание. Также имеется возможность провести тестирование по времени для разного количества потоков или разной длины отрезков в пучке.
