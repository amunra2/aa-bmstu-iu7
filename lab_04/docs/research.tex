\chapter{Исследовательская часть}

В данном разделе будут приведены примеры работы программа, а также проведен сравнительный анализ алгоритмов при различных ситуациях на основе полученных данных.

\section{Технические характеристики}

Технические характеристики устройства, на котором выполнялось тестирование представлены далее:

\begin{itemize}
    \item операционная система: Ubuntu 20.04.3 \cite{ubuntu} Linux \cite{linux} x86\_64;
    \item память: 8 GiB;
    \item процессор: Intel® Core™ i5-7300HQ CPU @ 2.50GHz \cite{intel};
    \item 4 физических ядра, 4 логических ядра \cite{intel}.
\end{itemize}

При тестировании ноутбук был включен в сеть электропитания. Во время тестирования ноутбук был нагружен только встроенными приложениями окружения, а также системой тестирования.

\section{Демонстрация работы программы}

На рисунке \ref{img:example} представлен результат работы программы.

\imgHeight{100mm}{example}{Пример работы программы}
\clearpage

\section{Время выполнения алгоритмов}

Как было сказано выше, используется функция замера процессорного времени \textit{std::chrono::system\_clock::now(...)} из библиотеки $chrono$ на C++. Функция возвращает процессорное время типа float в секундах.

Использовать функцию приходится дважды, затем из конечного времени нужно вычесть начальное, чтобы получить результат.

Замеры проводились для разной длины отрезка в спектре, а также для разного количества потоков по 300 прогонов, для получения более точного значения времени.

Результаты замеров приведены в таблицах \ref{tbl:time_mes_par}-\ref{tbl:time_mes_difdiam} (время в с).

\begin{table}[h]
    \begin{center}
        \begin{threeparttable}
        \captionsetup{justification=raggedright,singlelinecheck=off}
        \caption{Результаты замеров времени (разное количество потоков, длина отрезка в спектре - 500)}
        \label{tbl:time_mes_par}
        \begin{tabular}{|p{6cm}|p{6cm}|}
            \hline
            Кол-во потоков & Результат \\
            \hline
            1 & 0.000581 \\ \hline 
            2 & 0.000284 \\ \hline 
            4 & 0.000245 \\ \hline 
            8 & 0.00031 \\ \hline 
            16 & 0.000413 \\ \hline 
            24 & 0.000545 \\ \hline 
            32 & 0.000733 \\ \hline 
		\end{tabular}
    \end{threeparttable}
\end{center}
\end{table}


\begin{table}[h]
    \begin{center}
        \begin{threeparttable}
        \captionsetup{justification=raggedright,singlelinecheck=off}
        \caption{Результаты замеров времени (без распараллеливания, длина отрезка в спектре - 500)}
        \label{tbl:time_mes_nopar}
        \begin{tabular}{|p{6cm}|p{6cm}|}
            \hline
            Номер & Результат \\
            \hline
            1 & 0.000902 \\ \hline 

		\end{tabular}
    \end{threeparttable}
\end{center}
\end{table}


\begin{table}[h]
    \begin{center}
        \begin{threeparttable}
        \captionsetup{justification=raggedright,singlelinecheck=off}
        \caption{Результаты замеров времени (длина отрезка в спектре - разная)}
        \label{tbl:time_mes_difdiam}
        \begin{tabular}{|c|c|c|}
            \hline
            Длина отрезка & 4 потока & Без многопоточности \\
            \hline
            1000 & 0.0006 & 0.001557 \\ \hline  
            2000 & 0.001058 & 0.003055 \\ \hline
            3000 & 0.001515 & 0.004551 \\ \hline
            4000 & 0.002919 & 0.006259 \\ \hline 
            5000 & 0.002382 & 0.007511 \\ \hline 
            6000 & 0.002842 & 0.009324 \\ \hline 
            7000 & 0.003277 & 0.010391 \\ \hline 
            8000 & 0.003699 & 0.012398 \\ \hline 
            9000 & 0.004686 & 0.013251 \\ \hline
            10000 & 0.004546 & 0.014771 \\ \hline  

		\end{tabular}
    \end{threeparttable}
\end{center}
\end{table}

\clearpage

Также на рисунках \ref{img:graph_par_and_nopar}--\ref{img:graph_difdiam} приведены графические результаты замеров.

\imgHeight{100mm}{graph_par_and_nopar}{Сравнение по времени алгоритмов построения спектра отрезков по Брезенехему -- разное количество потоков и без распараллеливания}
\imgHeight{100mm}{graph_difdiam}{Сравнение по времени алгоритмов построения спектра отрезков по Брезенехему -- разная длина отрезка в спектре}

\clearpage


\section{Вывод}

В результате эксперимента было получено, что при испольозвании 4 потоков, многопоточная реализация алгоритма построения спектра отрезков по Брезенехему лучше реализации без многопоточности в 3.7 раза на длине отрезка в спектре, равной 500. Данное количество потоков обусловлено тем, что на ноутбуке, на котором проводилось тестирование ПО, имеется всего 4 логических ядра, а следовательно максимальное количество потоков, которого можно добиться, равно четырем. Также важную роль играет то, что работа распределяется примерно равно между всеми потоками, остатки работы отдаются крайнему потоку. При 4 потоках остатка не будет. Именно поэтому лучшие результаты достигаются именно на 4 потоках, даже не смотря на ресурсы, которые дополнительно затрачиваются на содержание потоков. В итоге, можно сказать, что при таких данных следует использовать многопоточную реализацию алгоритма.

Также при проведении эксперимента было выявлено, что при увеличении длины отрезка в спектре, много поточная реализация выдает лучшие результаты. Так, при длине отрезка, равно 3000 многопоточная реализация лучше реализации без многопоточности в 3 раза, а уже на длине отрезка, равной 10000 - в 3.3 раза. Следовательно, стоит использовать многопоточную реализацию при большой длине отрезка в спектре (свыше 5 тысяч).

Стоит также упомянуть, что при реализации алгоритма построения спектра отрезков пришлось воспользоваться таким понятием, как mutex. Дело в том, что при многопоточной обработке может возникнуть ситуация, когда несколько потоков в один момент времени в разные места пытаются поместить на канвас пиксель. В итоге, происходит неопределенное поведение -- часть пискселей помещается, а часть -- пропадает. Из-за этого была реализована блокировка части кода, которая отвечает за помещение пикселя на канвас с помощью mutex. Из-за этого эта работа, по сути, происходит в однопоточном режиме, а все вычисления параллельно -- потоки ждут своей очереди, чтобы поместить пиксель на канвас.
